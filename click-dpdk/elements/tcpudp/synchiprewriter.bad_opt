#ifndef CLICK_SynchIPRewriter_HH
#define CLICK_SynchIPRewriter_HH
#include "tcprewriter.hh"
#include "udprewriter.hh"
#include <iostream>
CLICK_DECLS
class UDPRewriter;

class SynchIPRewriter : public TCPRewriter { public:

    typedef UDPRewriter::UDPFlow UDPFlow;

    SynchIPRewriter();
    ~SynchIPRewriter();

    virtual const char *port_count() const    { return "1/3"; }
    virtual const char *processing() const    { return "h/hhh"; }


    const char *class_name() const		{ return "SynchIPRewriter"; }
    void *cast(const char *);

    int configure(Vector<String> &, ErrorHandler *);

    IPRewriterEntry *get_entry(int ip_p, const IPFlowID &flowid, int input);

    HashContainer<IPRewriterEntry> *get_map(int mapid) {
	    if (mapid == IPRewriterInput::mapid_default)
	      return &_map;
	    else if (mapid == IPRewriterInput::mapid_iprewriter_udp)
	      return &_udp_map;
	    else
	      return 0;
    }
    
    IPRewriterEntry *add_flow(int ip_p, const IPFlowID &flowid,
			      const IPFlowID &rewritten_flowid, int input);
    
    void destroy_flow(IPRewriterFlow *flow);
      click_jiffies_t best_effort_expiry(const IPRewriterFlow *flow) {
	    if (flow->ip_p() == IP_PROTO_TCP)
	      return TCPRewriter::best_effort_expiry(flow);
	    else
	      return flow->expiry() + udp_flow_timeout(static_cast<const UDPFlow *>(flow)) - _udp_timeouts[1];
    }

    void push(int, Packet *);

    void add_handlers();

  private:

    Map _udp_map;
    SizedHashAllocator<sizeof(UDPFlow)> _udp_allocator;
    uint32_t _udp_timeouts[2];
    uint32_t _udp_streaming_timeout;

    int udp_flow_timeout(const UDPFlow *mf) const {
  	  if (mf->streaming())
	        return _udp_streaming_timeout;
	     else
	        return _udp_timeouts[0];
    }

    static inline Map &reply_udp_map(IPRewriterInput *rwinput) {
	    SynchIPRewriter *x = static_cast<SynchIPRewriter *>(rwinput->reply_element);
	    return x->_udp_map;
    }
    static String udp_mappings_handler(Element *e, void *user_data);
  
    atomic_uint32_t _lk;

    uint64_t cur_threadid;
    uint16_t cur_thread_timesheld;


    void acquire_map_lock(){
      while(_lk.compare_swap(0, 1) != 0);

      //std::cout << _lk << " Lock acquired by " << threadid << std::endl; 
    }
    
    void send_locklog_pkt(uint64_t send_threadid, uint16_t send_timesheld){
        char* data = new char[10];
        memcpy(data, &send_threadid, 8);
        memcpy(&(data[8]), &send_timesheld, 2);
        WritablePacket* newpkt = Packet::make((const void*) data, 10);
        output(2).push(newpkt);
    }

    void release_map_lock(){
 
      uint64_t send_threadid = 0;
      uint16_t send_timesheld = 0;

      uint64_t threadid = pthread_self(); 
      if(threadid == cur_threadid){
        cur_thread_timesheld++;
      }
      else{
        send_threadid = cur_threadid;
        send_timesheld = cur_thread_timesheld;
        cur_threadid = threadid;
        cur_thread_timesheld = 1;
      }   
      _lk.swap(0);

      //Packet generation after critical section
      if(send_threadid != 0){
        send_locklog_pkt(send_threadid, send_timesheld);
      }
    }
};


inline void
SynchIPRewriter::destroy_flow(IPRewriterFlow *flow)
{
    acquire_map_lock();
    if (flow->ip_p() == IP_PROTO_TCP)
	TCPRewriter::destroy_flow(flow);
    else {
	unmap_flow(flow, _udp_map, &reply_udp_map(flow->owner()));
	flow->~IPRewriterFlow();
	_udp_allocator.deallocate(flow);
    }
    release_map_lock();
}

CLICK_ENDDECLS
#endif
