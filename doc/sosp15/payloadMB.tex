%!TEX root = mb.tex



\section{Middlebox: IDS}\label{sec:ids}
Unlike the previously presented middleboxes, devices which perform Intrusion Detection/Prevention (IDS/IPS) operate over the TCP bytestream, not just over packets and headers independently.
Hence, deploying an IDS at the cloud requires a stateful gateway at the enterprise.

\sys's IDS is based on BlindBox~\cite{blindbox}, an IDS which uses searchable encryption to detect malicious signatures within encrypted HTTPS connections. We highlight the functionality of BlindBox as follows, but exclude many important details all of which are presented in~\cite{blindbox}

We use BlindBox as follows.
BlindBox leaves HTTPS unmodified, but augments it with a secondary channel which transmits encrypted {\it exact match tokens}.
In it's simplest implementation, for every byte transmitted over HTTPS, the sender transmits an encrypted token using using the same approach as our keyword match algorithm.
The encrypted token encodes that byte, and the next 8 bytes; \eg{}, a sender transmitting the word `maliciousl' would transmit the encrypted tokens for [$\enc$(`maliciou'), $\enc$(`alicious')].
An IDS looking for the word `malicious' would declare a match if it observed both these tokens consecutively.
In practice, the sender does not send encrypted tokens for {\it every} byte, but optimizes out some which are redundant or unnecessary (we defer to~\cite{blindbox} for details about these optimizations).
For IDS signatures which consist {\it only} of exact match rules, keyword match is sufficient to detect attacks.
The security guarantee it gives is as follows: the IDS will learn what a byte in the flow is if it is {\it suspicious}, \ie{}, it matches a substring of a known attack.

  However, for IDS signatures which include regular expressions, keyword match is not sufficient to completely perform signature detection; further, there exists no \todo{RALUCA::: FAST ENOUGH SCHEME} to detect over encrypted data).
  Hence, to support regular expressions, BlindBox -- and \sys -- provide a secondary protocol with a different security guarantee. 
  All IDS rules include exact match strings -- for performance reasons, an IDS like Snort~\cite{Snort} only performs regular expression detection after all exact match strings have been detected first.
  Inspired by this, BlindBox allows the middlebox to decrypt the session {\it only} if suspicious exact match strings have already been detected.
  The client encodes the key with the tokens such that if a match occurs, the middlebox can automatically decrypt the key (once again, details are in~\cite{blindbox}).
  This approach can detect regular expressions, but provides a different security guarantee. 
  The first model allows the middlebox to {\it detect a substring, only if that substring is suspicious.} 
  The second model allows the middlebox to {\it decrypt the entire stream} of a substring is suspicious.
  This model is called `probable cause decryption'.

  Everything we have described to this point is identical between BlindBox and \sys. We now describe how they are different, and how this improves performance and security.

The key difference between BlindBox and how \sys implements IDS comes in how rules are given the IDS.
With \sys, the gateway can simply encrypt rules with its key $k$ and transmit them to the IDS, who then applices them over the enterprises traffic.
With BlindBox, this is not appropriate.
BlindBox aims to allow a client (\eg{} laptop) connecting to {\em any} network to receive IDS processing over their HTTP traffic, even if the IDS is unknown or untrusted to them.
In this scenario, the IDS wants to {\it enforce} that all traffic be scanned for malicious behavior, but the client wants to maintain {\it privacy} from the untrusted IDS.
The middlebox will not give its rules to the client, and the client will not give its key to the middlebox.
 To generate the encrypted rules that the IDS can use for detection requires BlindBox to perform
a sophisticated computation at the start of each connection, which makes the connection
startup time be slow. 
Further, this computation scales with the number of exact-match rules the IDS needs to learn: the more rules, the longer the startup time.
\sys has no such overhead.

The first implication of this is performance: this startup time is eliminated, as the rules are generated once, at the gateway, and transmitted to the IDS. After this there is no more setup cost.

The second implication is improved security security. We showed how BlindBox has a stronger security guarantee for exact matches than it does for regular expressions. However, many regular expressions can be converted to exact matches. 
For example, the regular expression 'alice[1-3]' is equivalent to any of the exact matches [`alice1', `alice2', `alice3'].
To do this expansion with BlindBox would be prohibitively expensive, as each additional exact match rules increases the already lengthy setup time.
However, as \sys has no such cost, we can expand many regular expressions and thus detect them using the stronger security model.
Not all rules are amenable to this -- \eg{} `bob[a-z]+' would result in a prohibitively large (and also far too general) number of expansions, even for \sys. 
In \S\ref{sec:eval}, we find for some rulsets regular expression expansion almost doubles the number of rules that can be detected using the stronger security model.


\section{Middlebox: Proxy/cache}\label{s:proxy}
\todo{Cut out any of this, it's leftover text from something I tried that didn't work but didn't want to delete in cas it winds up being helpful}
They also {\it terminate} connections rather than allowing packets to ``pass through''.
When a client opens a new HTTP connection, a typical proxy will capture the client's SYN packet and open a new connection to the client, as if it were the web server the client wished to connect to. 
The proxy then opens a second connection in the background to the original web server, as if it were the client. :w

Multiple clients may attempt to access the same web page through the proxy, in which case, the proxy maintains multiple client-facing connections, but one or few persistent server-facing connections.
When a client sends a request for new content, the proxy can either forward the request to the web server, or, the proxy may serve the content from its {\it cache} -- images and content that other clients have already requested which the proxy then stored locally. 
Caching improves client-perceived performance because content is served from the proxy, which is closer to the client than the web server.

In order to understand what content the client is requesting (index.html from google.com, photo.jpg from flickr.com, \etc{}), the proxy must parse the HTTP header, which, unlike IP/TCP/UDP headers is variable-length (\eg{}, URLs may be any number of characters long, while port numbers are always 16 bytes long) and variable-offset (\eg{}, the IP source always appears 12 bytes from the beginning of the packet, where the HTTP method may appear anywhere within an HTTP payload).

\sys implements web proxying using the keyword match encryption algorithm. 
However, rather than encrypting fixed values at fixed locations, the \sys gateway parses the HTTP header to determine what data to encrypt.
Nevertheless, as we show in \S\ref{sec:eval}, this parsing has a negligible overhead on gateway throughput -- less than 1\% when added in addition to the existing encryption required for Firewalling and NAT.
We implement two versions of gateway encryption: one which uses the stateless gateway and can encode HTTP requests which are not pipelined, and one which uses the stateful gateway, which supports pipelined HTTP requests as well (we discuss the difference as follows).

First case: unpipelined. HTTP header is **always** the first few bytes in the first packet sent by the client -- so easy to know where to start parsing.
\begin{itemize}
\item architecture overview
\item HTTP request -- absolute url and Host + relative url
\item tokenization special case \\
    \begin{itemize}
    \item in order to fetch the url from the header
    \item tokenize HTTP methods: GET, POST, ...
    \item tokenize attribute names: "Host:"
    \item tokenize versions: "HTTP/1.1", ...
    \end{itemize}
\item walk through the whole process
\item do not support pipelining yet
\end{itemize}

- may want to say that it has an index for seaching fast the url which it can thanks to the det scheme


we are focusing on the transparent proxy
- discuss the kind of proxies we are focusing on

proxies have two benefits: latency savings which aplomb gives you 
and bandwidth savings, which aplomb does nogive you
 
L7 Proxy / Cache

explain how the proxy finds if there is  a match --looks at header bytes
extra field attached to the packet -- gateway understands http and points out file id, 

discuss both cases: cache miss and hit

- two indep tcp connections 

how to populate the cache: content providers pushing the content to CDNs, or the gateway understands
http and tags what is content and what is ID
oops justine forgot to mention this above

the web proxy needs to send http response 

proxy only looks at the top N bits corresponding to a large header and matches the file id with the entire path
and matches GET and a few others -- avoid parsing http this way


discuss how the proxy can reconstruct the response?
can proxy reconstruct the ip header and the http header  and the tcp header without being able to encrypt
--- check the http header details

With pipelined requests, we don't have the header is always the first part of the packet. Instead, we need to {\it reconstruct the payload} to tell where to parse. This is where we need to use the other gatway. Otherwise, the functionality is exactly the same above -- only now we operate on the reconstructed payload rather than the first few bytes of the first packet.


\section{Middlebox: Intrusion Detection}
Like proxies, Intrusion Detection/Prevention systems operate over packet payloads, not just the IP/TCP/UDP headers.
IDS/IPS are canonical examples of DPI devices.


