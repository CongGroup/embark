%!TEX root = mb.tex



\section{Middlebox: Firewall}\label{sec:firewall}

\todo{tie all apps in with the two basic operations}

We use the term ``firewall'' for stateful and stateless packet filters that filter the traffic based on network layers and transport layers. Stateless firewalls commonly examine the combination of the packet's source and destination address, its protocol, and for TCP/UDP traffic, its source and destination port number. Stateful firewalls additionally keep track of protocol states for each flow and retain packets until they have enough information to make decision. 

In sum, our RangeMatch scheme supports both types of firewalls. The gateway encrypts the rules from the cloud beforehand, and sends them back to the cloud. The cloud installs those rules to the firewall. After the initialization is finished, the gateway can encrypt the traffic and forward to the cloud, and the firewall in the cloud can process the traffic normally without modification. When the traffic gets back to the gateway, it gets decrypted.

\subsection{Firewall rules}
Firewalls from different vendors may vary significantly in terms of rule syntaxes and organizations. However,
in general both hardware and software firewalls have a few interfaces. Both ingress and egress of an interface 
can be associated with an access control list (ACL). Each ACL has a number of rules, possibly in the form 
<action, protocol, src ip, src port, dst ip, dst port>. Without loss of generality, we take \texttt{pf}, the 
default firewall under BSD, as an example to illustrate how \sys works with firewalls. Figure \ref{fig:fwrule1} 
shows an example of \texttt{pf} rules. 

\begin{figure}[h]\label{fig:fwrule1}
\begin{lstlisting}[frame=single]
ext_if = "kue0"

block out log quick on $ext_if \
from 157.161.48.0/24 to any

block in quick on $ext_if \
from any to 255.255.255.255

pass out on $ext_if proto tcp \
from any to any port 80
\end{lstlisting}
\caption{\texttt{pf} configuration example}
\end{figure}

To work with \sys, we need to rewrite the rules above. Using the \RM scheme, we encrypt all IP addresses, prefixes, and port numbers inside the rules. Note that \texttt{any} is the alias of \texttt{0.0.0.0/0}. Recall that in Section \ref{sec:range} we want to keep the chance of collision as low as possible, therefore we map the IPv4 addresses into the IPv6 space before encoding those values. For example, to encrypt the IP prefix \texttt{157.161.48.0/24}, the gateway first extends it to \texttt{::ffff:157.161.48.0/120}.
Now the prefix represents the range from \texttt{::ffff:157.161.48.0} to \texttt{::ffff:157.161.48.255}. The gateway then insert
both endpoints to the tree, and gets their encrypted values. 

Suppose those two values are \texttt{fd6a:1faf:577b:bee4:0:0:0:0} and
\texttt{fd6a:1faf:577b:bee4:0:1:0:1}. Note that we can't represent this range using a single prefix, instead it has to be 
represented by at least two prefixes (\texttt{fd6a:1faf:577b:bee4:0:0:0:0/96} and \texttt{fd6a:1faf:577b:bee4:0:1:0:0/127}).
In this case, we have to split the original rule into 2 new rules:

\begin{lstlisting}[frame=single]
block out log quick on $ext_if \
from fd6a:1faf:577b:bee4:0:0:0:0/96 to any

block out log quick on $ext_if \
from fd6a:1faf:577b:bee4:0:1:0:0/127 to any
\end{lstlisting}

\todo{evaluate how many additional new rules are needed.}

After the gateway has rewritten the rules, it sends the rules back to the firewall on the cloud so that the
firewall can filter packets using the new rules.

\subsection{Encryption and decryption}
Every time the gateway forwards a packet from the user, it replace the IPv4 header with the IPv6 header 
using the Stateless IP/ICMP Translation (SIIT) algorithm \cite{rfc2765}. The purpose of this operation is to leave 
enough address space for avoiding address collision. The gateway then encrypts the source IP, source port, 
destination IP, destination port fields using the Range Match scheme in Section \ref{sec:range}.

\todo{a diagram that shows the packet format before and after encryption}

\subsection{Remark}
A key feature of our scheme is that we don't require to change the firewall implementations. As we discussed in Section \ref{sec:range}, the central 
piece of firewalls is packet classification, which is essentially a problem of finding a hyper-rectangle that contains a point from a given set of hyper-rectangles. Our \RM scheme keeps the order among the coordinates of hyper-rectangles, and the order between the coordinates of hyper-rectangles and points. In other words, their topological relations are preserved. Therefore existing firewalls can still work with \sys without modification. This property is important, since many high-speed firewalls are implemented in hardware, which is difficult and expensive to redesign.

\section{Middlebox: NAT}\label{sec:nat}

give example of what a rule becomes

\section{Middlebox: IDS}\label{sec:ids}
Unlike the previously presented middleboxes, devices which perform Intrusion Detection/Prevention (IDS/IPS) operate over the TCP bytestream, not just over packets and headers independently.
For IDSes, reconstructing the TCP bytestream allows the middlebox to detect attack strings which may span two or more packets.
Many other `stateful DPI' devices reconstruct the TCP bytestream while allowing packets to pass through, such as application firewalls and parental filters.
Due to this reconstruction cost, devices which perform stateful DPI typically provide much lower throughput than devices which perform
solely on headers -- for example~\todo{cite some industrial boxes here}.
Other devices also operate at the bytestream abstraction by terminating the TCP connection, \eg{} HTTP proxies, which must cache entire images (which would normally be divided across multiple packets). 

As we have seen with the previous middleboxes (Firewalls, NAT, Load Balancers), the \sys gateway can support middleboxes which operate on a packet-by-packet basis while similarly remaining stateless and operating on a packet-by-packet basis itself.
To support IDSes, however, we must use a modified gateway which supports bytestream-aware middleboxes by reconstructing the TCP flow at the middlebox.
As we show in~\S\ref{sec:eval}, the stateful gateway achieves lower throughput than the stateless one.
Fortunately, not all bytestream-aware middleboxes require a stateful, bytestream-aware gateway. 
As we shall see, some HTTP proxies -- proxies for non-pipelined HTTP requests -- can be fully supported with a stateless \sys gateway (pipelined HTTP proxies, however, do require a stateful gateway).

\sys's IDS is based on BlindBox~\cite{blindbox}, an IDS which 

\section{Middlebox: Proxy/cache}\label{s:proxy}
\todo{Cut out any of this, it's leftover text from something I tried that didn't work but didn't want to delete in cas it winds up being helpful}
They also {\it terminate} connections rather than allowing packets to ``pass through''.
When a client opens a new HTTP connection, a typical proxy will capture the client's SYN packet and open a new connection to the client, as if it were the web server the client wished to connect to. 
The proxy then opens a second connection in the background to the original web server, as if it were the client. 
Multiple clients may attempt to access the same web page through the proxy, in which case, the proxy maintains multiple client-facing connections, but one or few persistent server-facing connections.
When a client sends a request for new content, the proxy can either forward the request to the web server, or, the proxy may serve the content from its {\it cache} -- images and content that other clients have already requested which the proxy then stored locally. 
Caching improves client-perceived performance because content is served from the proxy, which is closer to the client than the web server.

In order to understand what content the client is requesting (index.html from google.com, photo.jpg from flickr.com, \etc{}), the proxy must parse the HTTP header, which, unlike IP/TCP/UDP headers is variable-length (\eg{}, URLs may be any number of characters long, while port numbers are always 16 bytes long) and variable-offset (\eg{}, the IP source always appears 12 bytes from the beginning of the packet, where the HTTP method may appear anywhere within an HTTP payload).

\sys implements web proxying using the keyword match encryption algorithm. 
However, rather than encrypting fixed values at fixed locations, the \sys gateway parses the HTTP header to determine what data to encrypt.
Nevertheless, as we show in \S\ref{sec:eval}, this parsing has a negligible overhead on gateway throughput -- less than 1\% when added in addition to the existing encryption required for Firewalling and NAT.
We implement two versions of gateway encryption: one which uses the stateless gateway and can encode HTTP requests which are not pipelined, and one which uses the stateful gateway, which supports pipelined HTTP requests as well (we discuss the difference as follows).

First case: unpipelined. HTTP header is **always** the first few bytes in the first packet sent by the client -- so easy to know where to start parsing.
\begin{itemize}
\item architecture overview
\item HTTP request -- absolute url and Host + relative url
\item tokenization special case \\
    \begin{itemize}
    \item in order to fetch the url from the header
    \item tokenize HTTP methods: GET, POST, ...
    \item tokenize attribute names: "Host:"
    \item tokenize versions: "HTTP/1.1", ...
    \end{itemize}
\item walk through the whole process
\item do not support pipelining yet
\end{itemize}

- may want to say that it has an index for seaching fast the url which it can thanks to the det scheme


we are focusing on the transparent proxy
- discuss the kind of proxies we are focusing on

proxies have two benefits: latency savings which aplomb gives you 
and bandwidth savings, which aplomb does nogive you
 
L7 Proxy / Cache

explain how the proxy finds if there is  a match --looks at header bytes
extra field attached to the packet -- gateway understands http and points out file id, 

discuss both cases: cache miss and hit

- two indep tcp connections 

how to populate the cache: content providers pushing the content to CDNs, or the gateway understands
http and tags what is content and what is ID
oops justine forgot to mention this above

the web proxy needs to send http response 

proxy only looks at the top N bits corresponding to a large header and matches the file id with the entire path
and matches GET and a few others -- avoid parsing http this way


discuss how the proxy can reconstruct the response?
can proxy reconstruct the ip header and the http header  and the tcp header without being able to encrypt
--- check the http header details

With pipelined requests, we don't have the header is always the first part of the packet. Instead, we need to {\it reconstruct the payload} to tell where to parse. This is where we need to use the other gatway. Otherwise, the functionality is exactly the same above -- only now we operate on the reconstructed payload rather than the first few bytes of the first packet.


\section{Middlebox: Intrusion Detection}
Like proxies, Intrusion Detection/Prevention systems operate over packet payloads, not just the IP/TCP/UDP headers.
IDS/IPS are canonical examples of DPI devices.


\section{Other middleboxes}\label{sec:vpn} \label{sec:other_apps} \label{sec:not_supp}\label{sec:loadb}
\qu{should we call them applications or middleboxes in the sections above?}


L4 load balancer
L7 load balancer

-- VPN naturally remains the same. 

-- make the tables of applications consistent with each other and make sure we support all 

-- what is difference between L4 and L7 load balancer -- do we need both?

-- IP forwarding app, what is that?

-- how about the application firewall?

-- discuss wan optimizers and compression, that aplomb does not really support them in the basic model (requiring this special model that is not quite aplomb) -- also the conflicts it would show up for us
