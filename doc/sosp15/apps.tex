%!TEX root = mb.tex
\section{Applications}

\todo{tie all apps in with the two basic operations}

In this section we present how to apply the building blocks to real-world applications.

\section{Application: Firewall}\label{sec:firewall}
We use the term ``firewall'' for stateful and stateless packet filters that filter the traffic based on network layers and transport layers. Stateless firewalls commonly examine the combination of the packet's source and destination address, its protocol, and for TCP/UDP traffic, its source and destination port number. Stateful firewalls additionally keep track of protocol states for each flow and retain packets until they has enough information to make decision. 

In sum, the \RM scheme supports both types of firewalls. The gateway encrypts the rules from the cloud beforehand, and send them back to the cloud. The cloud installs those rules to the firewall. After the initialization is finished, the gateway can encrypt the traffic and forward to the cloud, and the firewall in the cloud can process the traffic normally without modification. When the traffic gets back to the gateway, it gets decrypted.

\subsection{Firewall rules}
Firewalls from different vendors may vary significantly in terms of rule syntaxes and organizations. However,
in general both hardware and software firewalls have a few interfaces. Both ingress and egress of an interface 
can be associated with an access control list (ACL). Each ACL has a number of rules, possibly in the form 
<action, protocol, src ip, src port, dst ip, dst port>. Without loss of generality, we take \texttt{pf}, the 
default firewall under BSD, as an example to illustrate how \sys works with firewalls. Figure \ref{fig:fwrule1} 
shows an example of \texttt{pf} rules. 

\begin{figure}[h]\label{fig:fwrule1}
\begin{lstlisting}[frame=single]
ext_if = "kue0"

block out log quick on $ext_if \
from 157.161.48.0/24 to any

block in quick on $ext_if \
from any to 255.255.255.255

pass out on $ext_if proto tcp \
from any to any port 80
\end{lstlisting}
\caption{\texttt{pf} configuration example}
\end{figure}

To work with \sys, we need to rewrite the rules above. Using the \RM scheme, we encode all IP addresses, prefixes, and port numbers inside the rules. Note that \texttt{any} is the alias of \texttt{0.0.0.0/0}. Recall that in Section \ref{sec:range} we want to keep the chance of collision as low as possible, therefore we map the IPv4 addresses into the IPv6 space before encoding those values. For example, to encode the IP prefix \texttt{157.161.48.0/24}, the gateway first extends it to \texttt{::ffff:157.161.48.0/120}.
Now the prefix represents the range from \texttt{::ffff:157.161.48.0} to \texttt{::ffff:157.161.48.255}. The gateway then insert
both endpoints to the tree, and gets their encoded values. 

Suppose those two values are \texttt{fd6a:1faf:577b:bee4:0:0:0:0} and
\texttt{fd6a:1faf:577b:bee4:0:1:0:1}. Note that we can't represent this range using a single prefix, instead it has to be 
represented by at least two prefixes (\texttt{fd6a:1faf:577b:bee4:0:0:0:0/96} and \texttt{fd6a:1faf:577b:bee4:0:1:0:0/127}).
In this case, we have to split the original rule into 2 new rules:

\begin{lstlisting}[frame=single]
block out log quick on $ext_if \
from fd6a:1faf:577b:bee4:0:0:0:0/96 to any

block out log quick on $ext_if \
from fd6a:1faf:577b:bee4:0:1:0:0/127 to any
\end{lstlisting}

\todo{evaluate how many additional new rules are needed.}

After the gateway has rewritten the rules, it sends the rules back to the firewall on the cloud so that the
firewall can filter packets using the new rules.

\subsection{Encryption and decryption}
Every time the gateway forwards a packet from the user, it replace the IPv4 header with the IPv6 header 
using the Stateless IP/ICMP Translation (SIIT) algorithm \cite{rfc2765}. The purpose of this operation is to leave 
enough address space for avoiding address collision. The gateway then encrypts the source IP, source port, 
destination IP, destination port fields using the Range Match scheme in Section \ref{sec:range}.

\todo{a diagram that shows the packet format before and after encryption}

\subsection{Remark}
A key feature of our scheme is that we don't require to change the firewall implementations. As we discussed in Section \ref{sec:range}, the central 
piece of firewalls is packet classification, which is essentially a problem of finding a hyper-rectangle that contains a point from a given set of hyper-rectangles. Our \RM scheme keeps the order among the coordinates of hyper-rectangles, and the order between the coordinates of hyper-rectangles and points. In other words, their topological relations are preserved. Therefore existing firewalls can still work with \sys without modification. This property is important, since many high-speed firewalls are implemented in hardware, which is difficult and expensive to redesign.

\section{Application: NAT}\label{sec:nat}

give example of what a rule becomes

\section{Application: Load balancer}\label{sec:loadb}

L4 load balancer
L7 load balancer

\section{Application: IDS and Exfiltration}\label{sec:IDS}

\todo{tie into the story of keyword match}

A lot of middleboxes run intrusion detection systems (IDS) and exfiltration services on the payload of network packets.
For example, middleboxes run network intrusion detection or IDS (e.g., using  Snort~\cite{Snort} 
or Bro~\cite{Bro}) to detect if packets from a compromised sender contain an attack and they 
perform data loss/ exfiltration prevention such as searching for watermarks in 
documents~\cite{CMU_exfiltration_report} to detect if an insider outsources confidential information.

In most of these systems, the middlebox has a set of {\em rules}, which are descriptions of attacks, and which 
the middlebox tries to match against the traffic. The rules can contain {\em rule strings} which should be matched
exactly against the traffic, offset information describing offsets in the packet where to search the rule string, and
sometimes even regular expressions.

To protect traffic privacy from the cloud, the payload of packets in \sys must be encrypted. 
However, how can the middlebox now perform the detection on the encrypted traffic? 
We know that nontrivial computation on encrypted data is very slow. ~\cite{CITE}

A recent system, BlindBox~\todo{cite},  enables detection at the middlebox on the encrypted traffic
in a practical way. 
Unfortunately, BlindBox was designed for a different network setting than our setting 
and does not fit our setting  as follows.


BlindBox was designed for the common network setting when the endpoints are users who generate
traffic that is encrypted and then sent through a middlebox. This means that the encryption algorithm
has access to the contiguous byte sequence of the traffic. In contrast, in \sys, the encryption 
happens at the gateway 
which only receives packets from the user endpoints. 
These packets can correspond to multiple flows and can be out of order, 
making it challenging to encrypt each packet in such a way that the middlebox can  {\em detect 
a rule string that spans multiple packets}, that is, a rule string where a part is at the end of a packet and the other part is at the beginning of the next packet.  Reconstructing the flow by putting the packets from each flow together and in order  is a very expensive 
operation. Performing such reconstruction at the gateway is 
very expensive, and would obviate a big part of the benefits of the Aplomb model. 


\sys addresses this issue through a new technique called {\em cross-packet detection}. Using this technique,
\sys can encrypt the packets in a special way that enables the middlebox to detect a rule string that spans multiple
packets. The gateway does not have to do flow reconstruction and can perform the encryption 
independently on a per packet basis. Only the middlebox
needs to perform flow reconstruction, which is the norm in IDS. 


Another difference of BlindBox's setting is the threat model. In BlindBox, user
endpoints perform the encryption and since a potential attacker is also a user, 
the endpoints are not trusted. As a result, in BlindBox the middlebox cannot
give the rules to the endpoints either because this will enable an attacker to eschew the
rules and because these rules are proprietary. In order to enable detection of the rules
over the encrypted data, they need to be encrypted with the same key as the 
key of the connection between the two endpoints. This situation requires BlindBox to perform
a sophisticated computation at the start of each connection, which makes the connection
startup time be slow. 


In our model, the gateway is performing the encryption, which is trusted. Even if the
user endpoint is malicious, the middlebox can share the rules with the gateway, and the
endpoint has no way of obtaining those rules. In \sys, we exploited this property to create a
much faster setup phase than in BlindBox. \todo{give some comparative numbers}




We now describe the common parts our system has to BlindBox and the new techniques we introduce. 





\subsection{Basic protocol}
\todo{keep this short because it is blindbox}

We now describe the part of our protocol that is common with BlindBox. 
We do not delve on the details that are similar to BlindBox and barely summarize them here.
For any details missed here, the reader should refer to the BlindBox paper~\cite{blindbox}.

The middlebox (MB) has a set of rules. The rules contain rule strings or regular expressions. 

For example, consider the  simplified rule number 2003296 from the Snort Emerging Threats ruleset:

\begingroup     \fontsize{9pt}{10pt}\selectfont
\begin{tabbing}
\green{alert} tcp \$EXTERNAL\_NET \$HTTP\_PORTS \\
\green{alert} tcp   \$EXTERNAL\_NET  \= \kill
\> -> \$HOME\_NET 1025:5000 ( \\

te \= content \= \kill
\> \green{content}:\ ``Server|3a| nginx/0.'';  \\
\> \green{content}:\ ``Content-Type|3a| text/html''; \\
\> \green{content}:\ ``|3a|80|3b|255.255.255.255''; )
\end{tabbing}
\endgroup

Each content must be matched exactly against the traffic. ``|'' denotes binary data. 

\paragraph{Connection setup.} 
Two endpoints setup a connection with SSL key $k$. 
In order for MB to detect a rule string (a content above) $r$ on encrypted traffic, it needs to have them encrypted 
under the same key $k$ with AES: $\aes_k(r)$. 
As explained, in BlindBox'es setup, MB cannot give $r$ to the users and the endpoints cannot give $k$ to MB 
(or else, they don't have any privacy). As a result, BlindBox employs a sophisticated algorithm for encrypting
these rules based on Yao garbled circuits~\cite{} which is slow. We will eliminate this slowdown in \S\ref{sec:IDS}.


\paragraph{Encrypt traffic at endpoint.}
The stream of data at each endpoint gets encrypted with SSL as before 
and separately with BlindBox. 
For the BlindBox encryption, the stream gets tokenized and then encrypted. 
The tokenization produces a set of keywords from the traffic stream (e.g.,
a keyword for every offset in the packet). Each token $t$ then gets encrypted using
a new and strong encryption scheme $\salt, H(\salt, \aes_k(t))$, where 
$\salt$ is a random value and $H$ is a hash. 

\paragraph{Match at middlebox.} 
Given an encrypted rule $\encr = \aes_k(r)$ and an encrypted token $t$ from the traffic
$\salt, c = H(\salt, \aes_k(t))$, the middlebox detects a match if $H(\salt, \encr) = c$. 
BlindBox has a faster detection algorithm that performs this matching and we use it too.


\paragraph{Security and functionality.}
BlindBox provides two types of security guarantees, SEC I and SEC II,  and we inherit these too. 
SEC I is stronger than SEC II, but SEC II can support more general functionality. 
Table~\ref{tab:BB_sec_func} in \S\ref{sec:eval} summarizes this tradeoff. 

SEC I: The first security guarantee is that the middlebox does not learn anything about the data
content except for which offsets match a malicious string, namely, a content in a rule. 
If a part of the packet does not match a rule, the middlebox does not learn the content 
of that part of the packet. The middlebox also learns the number of tokens, but not what
the tokens are. For this security guarantee, BlindBox can support fully exfiltration 
detection and a XXX of the rules of common IDS. 

SEC II: The second security guarantee is a bit weaker, but still meaningful. This allows BlindBox
to support regular expressions in a practical way, and thus support 100\% of IDS. 
The privacy model is called prabable cause privacy which says that the middlebox
learns an entire packet if the packet is suspicious (namely it contains a  malicious string from a rule). 
If a packet does not contain any such string, the middlebox does not learn the content of the packet as 
in SEC I. 

put BB table in Eval 


\subsection{\sys's IDS}\label{sec:IDS}

\subsubsection{Basic protocol}

However, the rules also need to be encrypted
under the key of the connection of the two users in order to be able to match the 
traffic of the two users. 

This protocol is based on BlindBox so we only explain it briefly, referring the reader for more details to~\cite{blindbox}. 


only what one needs to know

mention probable cause privacy, but no need to explain

mention something about functionality -- we preserve it

\subsubsection{\sys's IDS}


builds on blindbox

\subsubsection{Setup phase}


\subsubsection{Packet boundaries}



even though for this we use an existing scheme, we incorporate it into the whole
system and make it work with the other components

-- gateway checks that the rules from the service provider have a minimal length 

Bryan Ford, Mike Walfish and Brad Karp -- who are on Sigcomm PC are also on SOSP Pc
So we need to not kill BlindBox -- just present them as different, not as better necessarily.


\subsubsection{Strawman}
\begin{itemize}
\item packet: tokenization
\item signature
\item how to match
\item problem: signatures across boundaries
\end{itemize}

\subsubsection{Solution}
Packets:
\begin{itemize}
\item tokenize as usual
\item in addition, at the end of each packet, tokenize last k-1, ..., 1 bytes
\item at the beginning, tokenize first 1, 2, ..., k-1 bytes
\item suppose packet has a sequence number i, for a j-byte tail tokens, generate $e_k$(j bytes) XOR $prf_k$(i, k-j).
\item Similarly, for a j-byte head tokens, generate $e_k$(j bytes) XOR $prf_k$(i-1, j)
\end{itemize}

Signatures:
\begin{itemize}
\item tokenize
\item for each k byte token, also generate (1, k-1), (2, k-2), ..., (k-1, 1) byte token pairs
\item for each pair (p1, p2), ids keeps p1 XOR p2 as a signature.
\end{itemize}

How to match:
\begin{itemize}
\item for normal tokens, direct match
\item for head and tail tokens: when handling packet i and i+1, XOR the corresponding head and tail tokens with the signature.
\end{itemize}

\section{Application: Proxy/cache}\label{sec:proxy}
\begin{itemize}
\item architecture overview
\item HTTP request -- absolute url and Host + relative url
\item tokenization special case \\
    \begin{itemize}
    \item in order to fetch the url from the header
    \item tokenize HTTP methods: GET, POST, ...
    \item tokenize attribute names: "Host:"
    \item tokenize versions: "HTTP/1.1", ...
    \end{itemize}
\item walk through the whole process
\item do not support pipelining yet
\end{itemize}


we are focusing on the transparent proxy
- discuss the kind of proxies we are focusing on

proxies have two benefits: latency savings which aplomb does not give you 
and bandwidth savings, which aplomb gives you
 
L7 Proxy / Cache

explain how the proxy finds if there is  a match --looks at header bytes
extra field attached to the packet -- gateway understands http and points out file id, 

discuss both cases: cache miss and hit

- two indep tcp connections 

how to populate the cache: content providers pushing the content to CDNs, or the gateway understands
http and tags what is content and what is ID

the web proxy needs to send http response 

proxy only looks at the top N bits corresponding to a large header and matches the file id with the entire path
and matches GET and a few others -- avoid parsing http this way


discuss how the proxy can reconstruct the response?
can proxy reconstruct the ip header and the http header  and the tcp header without being able to encrypt
--- check the http header details


\subsection{Other applications}\label{sec:vpn} \label{sec:other} \label{sec:not_supp}
\todo{should we call them applications or middleboxes in the sections above?}

VPN naturally remains the same. 