%!TEX root = mb.tex
\section{Applications}
In this section we present how to apply the building blocks to real-world applications.

\subsection{Firewall}\label{sec:firewall}
We use the term ``firewall'' for stateful and stateless packet filters that filter the traffic based on network layers and transport layers. Stateless firewalls commonly examine the combination of the packet's source and destination address, its protocol, and for TCP/UDP traffic, its source and destination port number. Stateful firewalls additionally keep track of protocol states for each flow and retain packets until they has enough information to make decision. 

In sum, the \RM scheme supports both types of firewalls. The gateway encrypts the rules from the cloud beforehand, and send them back to the cloud. The cloud installs those rules to the firewall. After the initialization is finished, the gateway can encrypt the traffic and forward to the cloud, and the firewall in the cloud can process the traffic normally without modification. When the traffic gets back to the gateway, it gets decrypted.

\subsubsection{Firewall rules}
Firewalls from different vendors may vary significantly in terms of rule syntaxes and organizations. However,
in general both hardware and software firewalls have a few interfaces. Both ingress and egress of an interface 
can be associated with an access control list (ACL). Each ACL has a number of rules, possibly in the form 
<action, protocol, src ip, src port, dst ip, dst port>. Without loss of generality, we take \texttt{pf}, the 
default firewall under BSD, as an example to illustrate how \sys works with firewalls. Figure \ref{fig:fwrule1} 
shows an example of \texttt{pf} rules. 

\begin{figure}[h]\label{fig:fwrule1}
\begin{lstlisting}[frame=single]
ext_if = "kue0"

block out log quick on $ext_if \
from 157.161.48.0/24 to any

block in quick on $ext_if \
from any to 255.255.255.255

pass out on $ext_if proto tcp \
from any to any port 80
\end{lstlisting}
\caption{\texttt{pf} configuration example}
\end{figure}

To work with \sys, we need to rewrite the rules above. Using the \RM scheme, we encode all IP addresses, prefixes, and port numbers inside the rules. Note that \texttt{any} is the alias of \texttt{0.0.0.0/0}. Recall that in Section \ref{sec:range} we want to keep the chance of collision as low as possible, therefore we map the IPv4 addresses into the IPv6 space before encoding those values. For example, to encode the IP prefix \texttt{157.161.48.0/24}, the gateway first extends it to \texttt{::ffff:157.161.48.0/120}.
Now the prefix represents the range from \texttt{::ffff:157.161.48.0} to \texttt{::ffff:157.161.48.255}. The gateway then insert
both endpoints to the tree, and gets their encoded values. 

Suppose those two values are \texttt{fd6a:1faf:577b:bee4:0:0:0:0} and
\texttt{fd6a:1faf:577b:bee4:0:1:0:1}. Note that we can't represent this range using a single prefix, instead it has to be 
represented by at least two prefixes (\texttt{fd6a:1faf:577b:bee4:0:0:0:0/96} and \texttt{fd6a:1faf:577b:bee4:0:1:0:0/127}).
In this case, we have to split the original rule into 2 new rules:

\begin{lstlisting}[frame=single]
block out log quick on $ext_if \
from fd6a:1faf:577b:bee4:0:0:0:0/96 to any

block out log quick on $ext_if \
from fd6a:1faf:577b:bee4:0:1:0:0/127 to any
\end{lstlisting}

\todo{evaluate how many additional new rules are needed.}

After the gateway has rewritten the rules, it sends the rules back to the firewall on the cloud so that the
firewall can filter packets using the new rules.

\subsubsection{Encryption and decryption}
Every time the gateway forwards a packet from the user, it replace the IPv4 header with the IPv6 header 
using the Stateless IP/ICMP Translation (SIIT) algorithm \cite{rfc2765}. The purpose of this operation is to leave 
enough address space for avoiding address collision. The gateway then encrypts the source IP, source port, 
destination IP, destination port fields using the Range Match scheme in Section \ref{sec:range}.

\todo{a diagram that shows the packet format before and after encryption}

\subsubsection{Remark}
A key feature of our scheme is that we don't require to change the firewall implementations. As we discussed in Section \ref{sec:range}, the central 
piece of firewalls is packet classification, which is essentially a problem of finding a hyper-rectangle that contains a point from a given set of hyper-rectangles. Our \RM scheme keeps the order among the coordinates of hyper-rectangles, and the order between the coordinates of hyper-rectangles and points. In other words, their topological relations are preserved. Therefore existing firewalls can still work with \sys without modification. This property is important, since many high-speed firewalls are implemented in hardware, which is difficult and expensive to redesign.

\subsection{NAT}\label{sec:nat}

give example of what a rule becomes

\subsection{Load balancer}\label{sec:loadb}

L4 load balancer
L7 load balancer

\subsection{IDS and Exfiltration}\label{sec:IDS}
\subsubsection{Strawman}
\begin{itemize}
\item packet: tokenization
\item signature
\item how to match
\item problem: signatures across boundaries
\end{itemize}

\subsubsection{Solution}
Packets:
\begin{itemize}
\item tokenize as usual
\item in addition, at the end of each packet, tokenize last k-1, ..., 1 bytes
\item at the beginning, tokenize first 1, 2, ..., k-1 bytes
\item suppose packet has a sequence number i, for a j-byte tail tokens, generate $e_k$(j bytes) XOR $prf_k$(i, k-j).
\item Similarly, for a j-byte head tokens, generate $e_k$(j bytes) XOR $prf_k$(i-1, j)
\end{itemize}

Signatures:
\begin{itemize}
\item tokenize
\item for each k byte token, also generate (1, k-1), (2, k-2), ..., (k-1, 1) byte token pairs
\item for each pair (p1, p2), ids keeps p1 XOR p2 as a signature.
\end{itemize}

How to match:
\begin{itemize}
\item for normal tokens, direct match
\item for head and tail tokens: when handling packet i and i+1, XOR the corresponding head and tail tokens with the signature.
\end{itemize}

\subsection{Proxy/cache}\label{sec:proxy}
\begin{itemize}
\item architecture overview
\item HTTP request -- absolute url and Host + relative url
\item tokenization special case \\
    \begin{itemize}
    \item in order to fetch the url from the header
    \item tokenize HTTP methods: GET, POST, ...
    \item tokenize attribute names: "Host:"
    \item tokenize versions: "HTTP/1.1", ...
    \end{itemize}
\item walk through the whole process
\item do not support pipelining yet
\end{itemize}

\subsection{Discussion of other middleboxes}\label{sec:vpn} \label{sec:other} \label{sec:not_supp}

VPN naturally remains the same. 