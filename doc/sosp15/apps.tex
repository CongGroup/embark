%!TEX root = mb.tex



\section{Middlebox: Firewall}\label{sec:firewall}

\todo{tie all apps in with the two basic operations}

We use the term ``firewall'' for stateful and stateless packet filters that filter the traffic based on network layers and transport layers. Stateless firewalls commonly examine the combination of the packet's source and destination address, its protocol, and for TCP/UDP traffic, its source and destination port number. Stateful firewalls additionally keep track of protocol states for each flow and retain packets until they have enough information to make decision. 

In sum, our RangeMatch scheme supports both types of firewalls. The gateway encrypts the rules from the cloud beforehand, and sends them back to the cloud. The cloud installs those rules to the firewall. After the initialization is finished, the gateway can encrypt the traffic and forward to the cloud, and the firewall in the cloud can process the traffic normally without modification. When the traffic gets back to the gateway, it gets decrypted.

\subsection{Firewall rules}
Firewalls from different vendors may vary significantly in terms of rule syntaxes and organizations. However,
in general both hardware and software firewalls have a few interfaces. Both ingress and egress of an interface 
can be associated with an access control list (ACL). Each ACL has a number of rules, possibly in the form 
<action, protocol, src ip, src port, dst ip, dst port>. Without loss of generality, we take \texttt{pf}, the 
default firewall under BSD, as an example to illustrate how \sys works with firewalls. Figure \ref{fig:fwrule1} 
shows an example of \texttt{pf} rules. 

\begin{figure}[h]\label{fig:fwrule1}
\begin{lstlisting}[frame=single]
ext_if = "kue0"

block out log quick on $ext_if \
from 157.161.48.0/24 to any

block in quick on $ext_if \
from any to 255.255.255.255

pass out on $ext_if proto tcp \
from any to any port 80
\end{lstlisting}
\caption{\texttt{pf} configuration example}
\end{figure}

To work with \sys, we need to rewrite the rules above. Using the \RM scheme, we encrypt all IP addresses, prefixes, and port numbers inside the rules. Note that \texttt{any} is the alias of \texttt{0.0.0.0/0}. Recall that in Section \ref{sec:range} we want to keep the chance of collision as low as possible, therefore we map the IPv4 addresses into the IPv6 space before encoding those values. For example, to encrypt the IP prefix \texttt{157.161.48.0/24}, the gateway first extends it to \texttt{::ffff:157.161.48.0/120}.
Now the prefix represents the range from \texttt{::ffff:157.161.48.0} to \texttt{::ffff:157.161.48.255}. The gateway then insert
both endpoints to the tree, and gets their encrypted values. 

Suppose those two values are \texttt{fd6a:1faf:577b:bee4:0:0:0:0} and
\texttt{fd6a:1faf:577b:bee4:0:1:0:1}. Note that we can't represent this range using a single prefix, instead it has to be 
represented by at least two prefixes (\texttt{fd6a:1faf:577b:bee4:0:0:0:0/96} and \texttt{fd6a:1faf:577b:bee4:0:1:0:0/127}).
In this case, we have to split the original rule into 2 new rules:

\begin{lstlisting}[frame=single]
block out log quick on $ext_if \
from fd6a:1faf:577b:bee4:0:0:0:0/96 to any

block out log quick on $ext_if \
from fd6a:1faf:577b:bee4:0:1:0:0/127 to any
\end{lstlisting}

\todo{evaluate how many additional new rules are needed.}

After the gateway has rewritten the rules, it sends the rules back to the firewall on the cloud so that the
firewall can filter packets using the new rules.

\subsection{Encryption and decryption}
Every time the gateway forwards a packet from the user, it replace the IPv4 header with the IPv6 header 
using the Stateless IP/ICMP Translation (SIIT) algorithm \cite{rfc2765}. The purpose of this operation is to leave 
enough address space for avoiding address collision. The gateway then encrypts the source IP, source port, 
destination IP, destination port fields using the Range Match scheme in Section \ref{sec:range}.

\todo{a diagram that shows the packet format before and after encryption}

\subsection{Remark}
A key feature of our scheme is that we don't require to change the firewall implementations. As we discussed in Section \ref{sec:range}, the central 
piece of firewalls is packet classification, which is essentially a problem of finding a hyper-rectangle that contains a point from a given set of hyper-rectangles. Our \RM scheme keeps the order among the coordinates of hyper-rectangles, and the order between the coordinates of hyper-rectangles and points. In other words, their topological relations are preserved. Therefore existing firewalls can still work with \sys without modification. This property is important, since many high-speed firewalls are implemented in hardware, which is difficult and expensive to redesign.

\section{Middlebox: NAT}\label{sec:nat}

give example of what a rule becomes

\section{Middlebox: IDS}\label{sec:ids}
Unlike the previously presented middleboxes, devices which perform Intrusion Detection/Prevention (IDS/IPS) operate over the TCP bytestream, not just over packets and headers independently.
Hence, deploying an IDS at the cloud requires a stateful gateway at the enterprise.

\sys's IDS is based on BlindBox~\cite{blindbox}, an IDS which uses searchable encryption to detect malicious signatures within encrypted HTTPS connections. We highlight the functionality of BlindBox as follows, but exclude many important details all of which are presented in~\cite{blindbox}

We use BlindBox as follows.
BlindBox leaves HTTPS unmodified, but augments it with a secondary channel which transmits encrypted {\it exact match tokens}.
In it's simplest implementation, for every byte transmitted over HTTPS, the sender transmits an encrypted token using using the same approach as our keyword match algorithm.
The encrypted token encodes that byte, and the next 8 bytes; \eg{}, a sender transmitting the word `maliciousl' would transmit the encrypted tokens for [$\enc$(`maliciou'), $\enc$(`alicious')].
An IDS looking for the word `malicious' would declare a match if it observed both these tokens consecutively.
In practice, the sender does not send encrypted tokens for {\it every} byte, but optimizes out some which are redundant or unnecessary (we defer to~\cite{blindbox} for details about these optimizations).
For IDS signatures which consist {\it only} of exact match rules, keyword match is sufficient to detect attacks.
The security guarantee it gives is as follows: the IDS will learn what a byte in the flow is if it is {\it suspicious}, \ie{}, it matches a substring of a known attack.

  However, for IDS signatures which include regular expressions, keyword match is not sufficient to completely perform signature detection; further, there exists no \todo{RALUCA::: FAST ENOUGH SCHEME} to detect over encrypted data).
  Hence, to support regular expressions, BlindBox -- and \sys -- provide a secondary protocol with a different security guarantee. 
  All IDS rules include exact match strings -- for performance reasons, an IDS like Snort~\cite{Snort} only performs regular expression detection after all exact match strings have been detected first.
  Inspired by this, BlindBox allows the middlebox to decrypt the session {\it only} if suspicious exact match strings have already been detected.
  The client encodes the key with the tokens such that if a match occurs, the middlebox can automatically decrypt the key (once again, details are in~\cite{blindbox}).
  This approach can detect regular expressions, but provides a different security guarantee. 
  The first model allows the middlebox to {\it detect a substring, only if that substring is suspicious.} 
  The second model allows the middlebox to {\it decrypt the entire stream} of a substring is suspicious.
  This model is called `probable cause decryption'.

  Everything we have described to this point is identical between BlindBox and \sys. We now describe how they are different, and how this improves performance and security.

The key difference between BlindBox and how \sys implements IDS comes in how rules are given the IDS.
With \sys, the gateway can simply encrypt rules with its key $k$ and transmit them to the IDS, who then applices them over the enterprises traffic.
With BlindBox, this is not appropriate.
BlindBox aims to allow a client (\eg{} laptop) connecting to {\em any} network to receive IDS processing over their HTTP traffic, even if the IDS is unknown or untrusted to them.
In this scenario, the IDS wants to {\it enforce} that all traffic be scanned for malicious behavior, but the client wants to maintain {\it privacy} from the untrusted IDS.
The middlebox will not give its rules to the client, and the client will not give its key to the middlebox.
 To generate the encrypted rules that the IDS can use for detection requires BlindBox to perform
a sophisticated computation at the start of each connection, which makes the connection
startup time be slow. 
Further, this computation scales with the number of exact-match rules the IDS needs to learn: the more rules, the longer the startup time.
\sys has no such overhead.

The first implication of this is performance: this startup time is eliminated, as the rules are generated once, at the gateway, and transmitted to the IDS. After this there is no more setup cost.

The second implication is improved security security. We showed how BlindBox has a stronger security guarantee for exact matches than it does for regular expressions. However, many regular expressions can be converted to exact matches. 
For example, the regular expression 'alice[1-3]' is equivalent to any of the exact matches [`alice1', `alice2', `alice3'].
To do this expansion with BlindBox would be prohibitively expensive, as each additional exact match rules increases the already lengthy setup time.
However, as \sys has no such cost, we can expand many regular expressions and thus detect them using the stronger security model.
Not all rules are amenable to this -- \eg{} `bob[a-z]+' would result in a prohibitively large (and also far too general) number of expansions, even for \sys. 
In \S\ref{sec:eval}, we find for some rulsets regular expression expansion almost doubles the number of rules that can be detected using the stronger security model.


\section{Middlebox: Proxy/cache}\label{s:proxy}
\todo{Cut out any of this, it's leftover text from something I tried that didn't work but didn't want to delete in cas it winds up being helpful}
They also {\it terminate} connections rather than allowing packets to ``pass through''.
When a client opens a new HTTP connection, a typical proxy will capture the client's SYN packet and open a new connection to the client, as if it were the web server the client wished to connect to. 
The proxy then opens a second connection in the background to the original web server, as if it were the client. :w

Multiple clients may attempt to access the same web page through the proxy, in which case, the proxy maintains multiple client-facing connections, but one or few persistent server-facing connections.
When a client sends a request for new content, the proxy can either forward the request to the web server, or, the proxy may serve the content from its {\it cache} -- images and content that other clients have already requested which the proxy then stored locally. 
Caching improves client-perceived performance because content is served from the proxy, which is closer to the client than the web server.

In order to understand what content the client is requesting (index.html from google.com, photo.jpg from flickr.com, \etc{}), the proxy must parse the HTTP header, which, unlike IP/TCP/UDP headers is variable-length (\eg{}, URLs may be any number of characters long, while port numbers are always 16 bytes long) and variable-offset (\eg{}, the IP source always appears 12 bytes from the beginning of the packet, where the HTTP method may appear anywhere within an HTTP payload).

\sys implements web proxying using the keyword match encryption algorithm. 
However, rather than encrypting fixed values at fixed locations, the \sys gateway parses the HTTP header to determine what data to encrypt.
Nevertheless, as we show in \S\ref{sec:eval}, this parsing has a negligible overhead on gateway throughput -- less than 1\% when added in addition to the existing encryption required for Firewalling and NAT.
We implement two versions of gateway encryption: one which uses the stateless gateway and can encode HTTP requests which are not pipelined, and one which uses the stateful gateway, which supports pipelined HTTP requests as well (we discuss the difference as follows).

First case: unpipelined. HTTP header is **always** the first few bytes in the first packet sent by the client -- so easy to know where to start parsing.
\begin{itemize}
\item architecture overview
\item HTTP request -- absolute url and Host + relative url
\item tokenization special case \\
    \begin{itemize}
    \item in order to fetch the url from the header
    \item tokenize HTTP methods: GET, POST, ...
    \item tokenize attribute names: "Host:"
    \item tokenize versions: "HTTP/1.1", ...
    \end{itemize}
\item walk through the whole process
\item do not support pipelining yet
\end{itemize}

- may want to say that it has an index for seaching fast the url which it can thanks to the det scheme


we are focusing on the transparent proxy
- discuss the kind of proxies we are focusing on

proxies have two benefits: latency savings which aplomb gives you 
and bandwidth savings, which aplomb does nogive you
 
L7 Proxy / Cache

explain how the proxy finds if there is  a match --looks at header bytes
extra field attached to the packet -- gateway understands http and points out file id, 

discuss both cases: cache miss and hit

- two indep tcp connections 

how to populate the cache: content providers pushing the content to CDNs, or the gateway understands
http and tags what is content and what is ID
oops justine forgot to mention this above

the web proxy needs to send http response 

proxy only looks at the top N bits corresponding to a large header and matches the file id with the entire path
and matches GET and a few others -- avoid parsing http this way


discuss how the proxy can reconstruct the response?
can proxy reconstruct the ip header and the http header  and the tcp header without being able to encrypt
--- check the http header details

With pipelined requests, we don't have the header is always the first part of the packet. Instead, we need to {\it reconstruct the payload} to tell where to parse. This is where we need to use the other gatway. Otherwise, the functionality is exactly the same above -- only now we operate on the reconstructed payload rather than the first few bytes of the first packet.


\section{Middlebox: Intrusion Detection}
Like proxies, Intrusion Detection/Prevention systems operate over packet payloads, not just the IP/TCP/UDP headers.
IDS/IPS are canonical examples of DPI devices.


\section{Other middleboxes}\label{sec:vpn} \label{sec:other_apps} \label{sec:not_supp}\label{sec:loadb}
\qu{should we call them applications or middleboxes in the sections above?}


L4 load balancer
L7 load balancer

-- VPN naturally remains the same. 

-- make the tables of applications consistent with each other and make sure we support all 

-- what is difference between L4 and L7 load balancer -- do we need both?

-- IP forwarding app, what is that?

-- how about the application firewall?

-- discuss wan optimizers and compression, that aplomb does not really support them in the basic model (requiring this special model that is not quite aplomb) -- also the conflicts it would show up for us
