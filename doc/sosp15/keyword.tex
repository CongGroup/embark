%!TEX root = mb.tex



\section{Building block: Keyword match}

\warning{this section is a mess. We need to decide what we do with cross-boundary match before I can fix it}
%\input{boundary}

Keyword match allows detecting if an encrypted keyword matches an encrypted data item by equality.
For example, given a certain type of encryption of the keyword ``malicious'', $\kwenc(``malicious'')$ someone can determine that it matches the second string in the list of encrypted data items [$\Enc$(``alice''), $\Enc$(``malicious''), $\Enc$(``alice'')] but it should learn nothing else about the other strings.

A few systems such as CryptDB~\cite{cryptdb, someother} used deterministic encryption for this purpose, which has the property that if $x = y$ then $\enc(x) = \enc(y)$. This encryption scheme is weaker than ours because it leaks equality relations even when no keyword is provided for matching. In contrast, we use strong encryption scheme, a randomized encryption scheme that leaks the minimum information needed: which string in the list matches the keyword and nothing else about the strings in the list. 

Since we are in a network setting where the matching is run over packets, sometimes a keyword to be matched spans two packets. \todo{give example here and explain why it is challenging}. Hence we had to come up with a new such scheme. \todo{it is a new contribution}

We employ two types of keyword matches: simple match (as above) and one for cross-boundary match. 


we will call the keywords rules because 

 and Enc(``malicious''), they should be able 

The API of this encryption scheme is in 


\begin{tabular}{c|c|c|c}
Scheme    & Function        & Input(s) & Output \\
\hline
 both                & $\keygen$     & security parameter	      & a secret key $k$ \\ 
                 & $\kwenc$	& $k$, a rule string $r$   &  encryption of $r$, $\encr$ \\
\hline
  simple               & $\enc$           &  $k$, a string $s$                        &  encryption of $s$, $\ct$          \\
                 & $\match$  & $\encr$, $\ct$ & yes/no if there is match \\
\hline
  cross-               & $\encleft$  & $k$, a string $s$ &encryption of $s$, $\ct_L$   \\
   boundary              & $\encright$ & $k$, a string $s$ & encryption of $s$, $\ct_R$  \\
                 & $\match$ & $\encr$, $\ct_L$, $\ct_R$ & yes/no if there is a match \\
\end{tabular}

-- make sure the API so far is clear and a reader can skip the crypto to the systems becasue they don't have
to understand it 
-- might be better without table because it is more clear
\todo{cross bondary has two rules in the encryption}

\subsection{Simple match}


searchable enc

more secure than DET

for full enc explain why it does not leak security, it was already proven and we dont need to 
also for DET point to that paper 

2 types:

- full and boundary
DET special case of full if we do not have repetitions

all randomized and strong

\begin{itemize}
\item deterministic enc
\item strawman: enc every byte -- not secure
\item solution: det enc + tokenization
\end{itemize}

\subsection{Cross-boundary match}

We present this encryption scheme when we talk about IDS in \S\ref{sec:IDS} because its API and design is
motivated by the network setting.
\todo{or should I extract it here?}


