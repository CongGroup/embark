%!TEX root = mb.tex

\todo{should have all header MBs into one section to save some space?}
\todo{would really make things better to have the borderbox send ipdates to all, you mention it here not much in overview, 
not useful for DPI anyways}
\todo{have a figure here}

\section{Middlebox: Firewall}\label{sec:firewall}

\todo{there was some text somewhere about a tool we use to switch to ipv6}

We use the term ``firewall'' for stateful and stateless packet filters that filter the traffic based on network layers and transport layers. Stateless firewalls commonly examine the combination of the packet's source and destination address, its protocol, and for TCP/ UDP traffic, its source and destination port number. Stateful firewalls additionally keep track of protocol states for each flow and retain packets until they have enough information to make decision. 
Our RangeMatch scheme supports both types of firewalls. We now explain the design of the firewall based on this scheme.

\mypara{Setup} Initially, the gateway (G) encrypts the rules to be used by the firewall, by encrypting all IP addresses and ports in the rules, as follows.


First, it prepares the IP and port intervals. Recall that RangeMatch requires the IP addresses to be IPv6 to guarantee the injectivity of encryption (see \S\ref{sec:range}); hence, we extend an IPv4 prefix  such as 157.161.48.0/24 to an IPv6 one  ::ffff:157.161.48.0/120. 
% Now the prefix represents the range from ::ffff:157.161.48.0 to ::ffff:157.161.48.255.
 This problem does not show up for ports because they only need to be distinct within the same IP address.
The gateway then expands every prefix into an interval, and every exact match $x$ into [$x$, $x$]. 

Next, the gateway encrypts these intervals using EncryptRanges (\S\ref{sec:range}) by running one instance of RangeMatch for IP addresses and one instance for ports.
It then convets each encrypted IP range into a set of prefixes and duplicates the rule for each prefix in this set. 

Consider an example rule from  \mf{pf}, the 
default firewall under BSD:
 \mf{ block out log quick on \$ext\_if from} \\ \mf{157.161.48.0/24 to any.}
Let the encryption of 157.161.48.0/24 be the interval [80.0.0.0, 160.0.0.0] (for brevity, we use IPv4y). 
This interval is equivalent to the prefixes: 80.0.0.0/4, 96.0.0.0/3, 144.0.0.0/4, and 160.0.0.0/32. 
Hence, the gateway replaces the original rule with four rules, one for each encrypted prefix. 
The worst-case number of prefixes for IPv6 is $O$($\min$($\log$ number of rules, $128$)) = $O$($\log$ number of rules), 
which is small. 


% Firewalls from different vendors may vary significantly in terms of rule syntaxes and organizations. However,
% in general both hardware and software firewalls have a few interfaces. Both ingress and egress of an interface 
% can be associated with an access control list (ACL). Each ACL has a number of rules, possibly in the form 
% <action, protocol, src ip, src port, dst ip, dst port>. Without loss of generality, we take \mf{pf}, the 
% default firewall under BSD, as an example to illustrate how \sys works with firewalls. Figure \ref{fig:fwrule1} 
% shows an example of \mf{pf} rules. 





The gateway sends the new rules to the service provider (SP) which installs them into the firewall {\em the same way it would install 
them if they were not encrypted}. 

\mypara{Processing traffic}
When a packet arrives at the gateway, the gateway encrypts its source/destination IP addresses and ports using the EncryptValue algorithm
and fits these into the packet header because RangeMatch is format preserving.
For example, for an IP address $v$, EncryptValue produces $\enc(v)$ and $\IV, \aes_k(\IV, v)$.
 $\enc(v)$ preserves the format of an IP address and hence 
it will fit in the packet header in the place of the unencrypted IP address.

Regarding $\IV, \aes_k(\IV, v)$, the gateway sends it along with the packet. SP's borderbox (see \S\ref{sec:overview})
removes this encryption from the packet and maintains a mapping between $\enc(v)$  and this AES encryption. 
When a packet comes in the reverse direction, from SP to the gateway, the borderbox reattaches the AES encryption so that the
gateway can decrypt the IP address.

After the packet passes the borderbox, it goes to the firewall. The firewall can execute on the encrypted header {\em
the same way as on the unencrypted header} because RangeMatch maintains the order relation between values in rules and in 
packet headers. 
In particular, it can use any of the existing fast matching algorithms unchanged. 
Moreover, it can still use  any specialized hardware without changes. This property is important, since many high-speed firewalls are implemented in hardware, which is difficult and expensive to redesign.


\mypara{Updating rules} 
Let us discuss the case of adding a new firewall rule; deleting a rule is similar.
The gateway runs AddRange from \S\ref{s:rangealg}. This produces a new encrypted range [$\enc(s), \enc(e)$] 
along with a list $L$ of other encrypted ranges that get updated. The gateway sends [$\enc(s), \enc(e)$] 
 and the list $L$ to the borderbox which broadcasts it to all the middleboxes.
This information is relevant to other middleboxes too: since the encryption of a value $v$ depends on the tree of ranges, an IP address $v$, which used to be encrypted into $e$ before the ranges were changed is now encrypted into $e'$; this can break logic at other middleboxes which stored $e'$. We discuss how the NAT uses this information in \S\ref{sec:nat}.

Using the prefix changes, the firewall 
 reconfigures the new set of rules. Due to the guarantees of our RangeMatch protocol, this list contains a 
small number (logarithmic) of intervals that changed, so the overhead for the reconfiguration should be modest.




\section{Middlebox: NAT}\label{sec:nat}
\todo{tie all apps in with the two basic operations}

give example of what a rule becomes

discuss what NAT with those changes 
