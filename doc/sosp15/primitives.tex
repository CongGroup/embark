%!TEX root = mb.tex

\section{Building blocks}\label{sec:blocks}

\todo{make sure apps use these building blocks and use the notation in this section}

\begin{itemize}
\item observation: operations performed by middleboxes are simple. for the applications we considered, range match and exact match are enough to cover those operations.
\item exact match: x == y iff e(x) == e(y), a weaker version: x == y iff R(e(x), e(y))
\item range match: x in [low, high] iff e(x) in [e(low), e(high)]

\end{itemize}


\section{Building block: Keyword match}


%\input{boundary}

Keyword match allows detecting if an encrypted keyword matches an encrypted data item by equality.
For example, given a certain type of encryption of the keyword ``malicious'', $\kwenc(``malicious'')$ someone can determine that it matches the second string in the list of encrypted data items [$\Enc$(``alice''), $\Enc$(``malicious''), $\Enc$(``alice'')] but it should learn nothing else about the other strings.

A few systems such as CryptDB~\cite{cryptdb, someother} used deterministic encryption for this purpose, which has the property that if $x = y$ then $\enc(x) = \enc(y)$. This encryption scheme is weaker than ours because it leaks equality relations even when no keyword is provided for matching. In contrast, we use strong encryption scheme, a randomized encryption scheme that leaks the minimum information needed: which string in the list matches the keyword and nothing else about the strings in the list. 

Since we are in a network setting where the matching is run over packets, sometimes a keyword to be matched spans two packets. \todo{give example here and explain why it is challenging}. Hence we had to come up with a new such scheme. \todo{it is a new contribution}

We employ two types of keyword matches: simple match (as above) and one for cross-boundary match. 


we will call the keywords rules because 

 and Enc(``malicious''), they should be able 

The API of this encryption scheme is in 


\begin{tabular}{c|c|c|c}
Scheme    & Function        & Input(s) & Output \\
\hline
 both                & $\keygen$     & security parameter	      & a secret key $k$ \\ 
                 & $\kwenc$	& $k$, a rule string $r$   &  encryption of $r$, $\encr$ \\
\hline
  simple               & $\enc$           &  $k$, a string $s$                        &  encryption of $s$, $\ct$          \\
                 & $\match$  & $\encr$, $\ct$ & yes/no if there is match \\
\hline
  cross-               & $\encleft$  & $k$, a string $s$ &encryption of $s$, $\ct_L$   \\
   boundary              & $\encright$ & $k$, a string $s$ & encryption of $s$, $\ct_R$  \\
                 & $\match$ & $\encr$, $\ct_L$, $\ct_R$ & yes/no if there is a match \\
\end{tabular}

-- make sure the API so far is clear and a reader can skip the crypto to the systems becasue they don't have
to understand it 
-- might be better without table because it is more clear
\todo{cross bondary has two rules in the encryption}

\subsection{Simple match}

\todo{FINISH}

searchable enc

more secure than DET

for full enc explain why it does not leak security, it was already proven and we dont need to 
also for DET point to that paper 

2 types:

- full and boundary
DET special case of full if we do not have repetitions

all randomized and strong

\begin{itemize}
\item deterministic enc
\item strawman: enc every byte -- not secure
\item solution: det enc + tokenization
\end{itemize}

\subsection{Cross-boundary match}

We present this encryption scheme when we talk about IDS in \S\ref{sec:IDS} because its API and design is
motivated by the network setting.
\todo{or should I extract it here?}

\section{Building block: Range match}
An important operation over an encrypted packet is to determine if an encrypted field in the packet falls in an encrypted range.
We will use the firewall as an example. 
Consider the following firewall rule:

Constructing an encryption scheme that allows checking if an encrypted value is in an encrypted range, has been a challenge in the applied cryptography community. The reason is that ..

\begin{itemize}
\item preserve the order between encoded values
\item candidate: OPE
\item candidate: mOPE
\item So none of the existing schemes are satisfactory. A new scheme \RM.
\end{itemize}

\RM applies to cases when we know an upper bound on the values encrypted with OPE and this is a small number of values (say, less than 10,000).

The small number of values permits us to improve in two ways over mOPE [1]
No more interaction. We store the tree in mOPE on the gateway (client) side, which means that the gateway can compute a new encryption by itself without help from service provider. The storage at the gateway will remain small.
Rare updates to ciphertexts. We can space out the ciphertexts of the values encrypted sufficiently. 

This also enjoys a stronger security than OPE! It leaks less than order.
The reason is that, the server does not learn the order between the values in packets, and only whether they map between two values in the rules. 

this one is new

discuss 

would be good to explain the challenge from the 

\todo{a more interesting name to the scheme}

prefix gets mapped into interval, at most a certain number

talk about building certain data structures that all works the same

firewall need not change 
